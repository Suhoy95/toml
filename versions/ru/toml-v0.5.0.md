![TOML Logo](../../logos/toml-200.png)

TOML v0.5.0
===========

Очевидный Минималистичный Язык Тома (Tom's Obvious, Minimal Language).

Автор: Том Престон-Вернер (Tom Preston-Werner).

Версия TOML 0.5.0 должна рассматриваться как предельно стабильная. Цель версии
1.0.0  быть обратно совместимой с версией 0.5.0 (на сколько это возможно,
с сохранением читаемости для человека). Авторам TOML имплементаций строго
рекомендуется реализовать совместимость с версией 0.5.0, что позволит
без особых затрат выполнить обновление к версии 1.0.0, когда это случиться.

Переводчик
----------

Перевод выполнен Сухоплюевым Ильей из компании Gramend Research & Development.
Просьба сообщать любые ошибки и неточности перевода с помощью стандартных
механизмов GitHub.

Уточнения перевода, не имеющие дословного аналога, встречаются следующим образом:

```markdown
*(Прим. Текст примечания от переводчика)*
```

Общие примечания:
- Лучшие практики (Best Practice) и слово "Рекомендуется" считать одним и тем же.
- Будьте бдительны так как "Строки" и производные слова могут означать, как TOML
тип данных, так и последовательность символов разделенных переносом строки
(строки в привычном смысле этого слова). Для устранения этой неоднозначности,
"Строки как тип" обозначаются с заглавной буквы, а строки в привычном виде будем
называть линия (line), пусть и звучит весьма костно.

Цели TOML
----------

TOML создан, чтобы быть минимальным конфигурационным файлом, который легко читать
*(Прим. как человеку, так и машине)* благодаря очевидной семантике.
TOML спроектирован для сопоставления TOML-файла и Хэш-таблицы. TOML должен быть
легок для разбора в структуры данных широкого спектра языков *(Прим. в частности языков программирования)*.

Содержание
-------

- [Пример](#user-content-example)
- [Спецификация](#user-content-spec)
- [Комментарии](#user-content-comment)
- [Пары Ключ/Значение (Key/Value)](#user-content-keyvalue-pair)
- [Ключи (Keys)](#user-content-keys)
- [Строки (Strings)](#user-content-string)
- [Целые числа (Integer)](#user-content-integer)
- [Числа с плавающей точкой (Float)](#user-content-float)
- [Логический тип (Boolean)](#user-content-boolean)
- [Тип Даты/Времени с часовым поясом (Offset Date-Time)](#user-content-offset-date-time)
- [Местная Дата/Время (Local Date-Time)](#user-content-local-date-time)
- [Местная дата (Local Date)](#user-content-local-date)
- [Местное время (Local Time)](#user-content-local-time)
- [Массив (Array)](#user-content-array)
- [Таблица (Table)](#user-content-table)
- [Однострочная Таблица (Inline Table)](#user-content-inline-table)
- [Массив Таблиц (Array of Tables)](#user-content-array-of-tables)
- [Расширение для TOML файлов](#user-content-filename-extension)
- [Сравнение с Другими Форматами](#user-content-comparison-with-other-formats)
- [Принять участие](#user-content-get-involved)
- [Wiki](#user-content-wiki)

Пример
------

```toml
# Это TOML документ.

title = "TOML Example"

[owner]
name = "Tom Preston-Werner"
dob = 1979-05-27T07:32:00-08:00 # Пример одного из типов Даты/Времени

[database]
server = "192.168.1.1"
ports = [ 8001, 8001, 8002 ]
connection_max = 5000
enabled = true

[servers]

  # Отступы )табы и/или пробелы разрешены, но необязательны
  [servers.alpha]
  ip = "10.0.0.1"
  dc = "eqdc10"

  [servers.beta]
  ip = "10.0.0.2"
  dc = "eqdc10"

[clients]
data = [ ["gamma", "delta"], [1, 2] ]

# Переход на новую строку допустим внутри массивов
hosts = [
  "alpha",
  "omega"
]
```

Спецификация
----

* TOML чувствителен к регистру.
* TOML-файл ДОЛЖЕН быть корректный (valid) UTF-8 Unicode документ.
* Пробел подразумевает ТАБ (0x09) или ПРОБЕЛ (0x20).
* Переход на новую строку подразумевает LF (0x0A) или CRLF (0x0D0A).

Комментарии
-----------

Символ решетки (`#`) означает комментарий до конца текущей строки.

```toml
# Это полнострочный комментарий
key = "value" # А этот комментарий закончиться в конце линии
```

Пары Ключ/Значение (Key/Value)
------------------------------

Основной элемент, из которого строиться TOML документ - пары Ключ/Значение
(key/value pair)
*(Прим. далее такая пара также встречается как Свойство (property))*.

Ключи располагаются слева от знака равенства, значения - справа. Пробельные
символы окружающие ключ и значение игнорируются. В общем случае, Ключ, Знак
равенства и Значение ДОЛЖНЫ быть на одной строке *(Прим. то есть не должны
включать в себя символов перевода строки)*(хотя, некоторые Значения могут
быть разбиты на несколько строк).

```toml
key = "value"
```

Значения должны быть описаны одним из следующих типов: Строка (String),
Целое число (Integer), Число с плавающей точкой (Float), Логический тип (Boolean),
Дата/Время (Datetime), Массив (Array), или Встроенная таблица (Inline Table).
Остальные Значения являются не допустимыми.

```toml
key = # НЕВЕРНЫЙ ФОРМАТ
```

Ключи
-----

Ключ может быть определен либо как есть (bare), либо закавычен (quoted) или
заточен (dotted).

**Простые Ключи (Bare keys)** могут содержать ASCII буквы, ASCII цифры,
знак подчеркивания, и тире (`A-Za-z0-9_-`). Заметьте, что простые ключи могут
состоять из одних ASCII цифр, например `1234`, но всегда Ключи интерпретируются
как строки.

```toml
key = "value"
bare_key = "value"
bare-key = "value"
1234 = "value"
```

**Закавыченные Ключи (Quoted keys)** следуют тем же самым правилам как обычные
строки (basic strings) или строковые литералы (literal strings)
*(Прим. "буквальные строки")*, что позволяет использовать широкий диапазон
символов в названиях Ключей. Рекомендуется и считается лучшей практикой (best
practice) *(Далее просто - рекомендуется)* использовать Простые Ключи, кроме
случаев, где это абсолютно необходимо.

```toml
"127.0.0.1" = "value"
"character encoding" = "value"
"ʎǝʞ" = "value"
'key2' = "value"
'quoted "value"' = "value"
```

Простые Ключи НЕ ДОЛЖНЫ быть пустыми, но пустые Закавыченные Ключи разрешены
(хотя и не желательны).

```toml
= "no key name"  # НЕВЕРНО
"" = "blank"     # ВЕРНО но не желательно
'' = 'blank'     # ВЕРНО но не желательно
```

**Заточенные Ключи (Dotted keys)** являются последовательностью Простых или
Закавыченных Ключей, соединенных точкой (dot, `.`). Данные тип позволяет
группировать похожие Свойства вместе:

```toml
name = "Orange"
physical.color = "orange"
physical.shape = "round"
site."google.com" = true
```

В землях JSON, эта запись выглядела бы следующим образом:

```json
{
  "name": "Orange",
  "physical": {
    "color": "orange",
    "shape": "round"
  },
  "site": {
    "google.com": true
  }
}
```

Пробельные символы вокруг Заточенных частей игнорируются, тем не менее,
рекомендуется не использовать какие-либо ненужные пробельные символы.

Объявление одного и того же Ключа несколько раз - НЕВЕРНО.

```
# НЕ ДЕЛАЙТЕ ТАК
name = "Tom"
name = "Pradyun"
```

До тех пор пока Ключ не объявлен явно, вы можете давать ему значение, а также
подзначения внутри него:

```
a.b.c = 1
a.d = 2
```

```
# ЭТОТ ПРИМЕР НЕ ВЕРЕН
a.b = 1
a.b.c = 2
```

Строки
------

Есть четыре способа записать Строки: обычный (basic), обычный многострочные
(multi-line basic), буквальный (literal), и буквальный многострочный
(multi-line literal). Все Строки ДОЛЖНЫ содержать только корректные
UTF-8 символы.

**Обычные Строки (Basic strings)** окружены кавычками. Любой Unicode Символ
может быть использован *(прим. в Строке)*, кроме тех что ДОЛЖНЫ быть
экранированы: знак кавычки, обратный слэш, и управляемые символы
(с `U+0000` по `U+001F`, `U+007F`).

```toml
str = "Я строка. \"Ты можешь меня закавычить\". Name\tJos\u00E9\nLocation\tSF."
```

Для удобства, некоторые популярные символы имеют компактную форму записи.

```
\b         - backspace       (U+0008)
\t         - tab             (U+0009)
\n         - linefeed        (U+000A)
\f         - form feed       (U+000C)
\r         - carriage return (U+000D)
\"         - quote           (U+0022)
\\         - backslash       (U+005C)
\uXXXX     - unicode         (U+XXXX)
\UXXXXXXXX - unicode         (U+XXXXXXXX)
```

Любой Unicode символ может быть выражен с помощью `\uXXXX` или `\UXXXXXXXX`
нотации. Такие коды ДОЛЖНЫ быть корректными Unicode [scalar values](http://unicode.org/glossary/#unicode_scalar_value).

Остальные экранируемые последовательности, не перечисленные выше, должны
вызывать ошибку, если таковые встретились в TOML документе.

Иногда, требуется выразить определенный отрывок текста (Как например,
файл с переводами) или было бы неплохо разбить очень длинные Строки на несколько
линий. TOML также легко решает эьу проблему.

**Многострочные Обычные Строки (Multi-line basic strings)** окружены тремя
последовательными знаками кавычки с каждой стороны, при этом переход на новую
линию в Строке разрешен.

Переход на новую строку сразу после открывающих тройных кавычек будет усечен.
Остальные Пробельные Символы и Символы Переноса Строки остаются не тронутыми.

```toml
str1 = """
Roses are red
Violets are blue"""
```

Парсеры TOML документов могут чувствовать свободу в нормализации перехода
на новую линию, до тех пор пока это имеет смысл для их платформы.

```toml
# В Unix системах, многострочная Строка выше будет, скорее всего, похожа на:
str2 = "Roses are red\nViolets are blue"

# В Windows системе, это, скорее всего, будет эквивалентно:
str3 = "Roses are red\r\nViolets are blue"
```

Для записи длинных строк без добавления избыточных Пробельных Символов
используйте "line ending backslash". Когда последний не-Пробельный Символ - это
обратный слэш (`\`), тогда все следующие после него Пробельные символы,
включая перенос строки, обрезаются вплоть до следующего не-Пробельного символа
или закрывающего разделителя. 

Все экранированные последовательности, которые корректны для Обычных Строк, также
корректны для Многострочных Обычных Строк.

```toml
# Следующие строки байт-в-байт эквивалентны:
str1 = "The quick brown fox jumps over the lazy dog."

str2 = """
The quick brown \


  fox jumps over \
    the lazy dog."""

str3 = """\
       The quick brown \
       fox jumps over \
       the lazy dog.\
       """
```

Любой Unicode символ может быть использован, кроме тех, что ДОЛЖНЫ быть 
экранированы: обратный слэш и контрольные символы (с `U+0000` по `U+001F`,
`U+007F`). Символы кавычек не требуется экранировать до тех пор пока они
не образуют полноценный завершающий разделитель.

Если вы часто работаете с Windows-путями или регулярными выражениями, то работа
с экранированными обратными слэшами быстро становиться утомительной и полной 
ошибок. В помощь этой ситуации TOML поддерживает Буквальные Строки
(literal strings), которые не допускают экранирования вовсе.

**Буквальные Строки (Literal strings)** окружены одинарными кавычками. Как и 
Обычные Строки, они должны помещаться на одной линии:

```toml
# Что видишь, то и получаешь
winpath  = 'C:\Users\nodejs\templates'
winpath2 = '\\ServerX\admin$\system32\'
quoted   = 'Tom "Dubs" Preston-Werner'
regex    = '<\i\c*\s*>'
```

Так как экранирование запрещено полностью, невозможно записать одинарную кавычку 
внутри Буквальной Строки. К счастью, TOML формат поддерживает Многострочную
версию Буквальных Строк, которая решает эту проблему.

**Многострочная Буквальная Строка Multi-line literal strings** окружена тремя 
последовательными одинарными кавычками с каждой стороны, и допускает символов 
Переноса Строки внутри. Как и в Буквальных Строках, здесь нет экранирования.

Перенос Строки, следующий сразу после открывающего разделителя будет усечен. 
Остальное содержание между разделителями интерпретируется КАК ЕСТЬ без какой-либо
модификации.

```toml
regex2 = '''I [dw]on't need \d{2} apples'''
lines  = '''
The first newline is
trimmed in raw strings.
   All other whitespace
   is preserved.
'''
```

Управляющие символы, отличные от ТАБ-а НЕ РАЗРЕШЕНЫ. Таким образом, для бинарных
данных рекомендуется использовать Base64 или любое другое подходящее ASCII
(или UTF-8) кодирование, а обработка подобных кодировок будет возлагаться на 
конкретное приложение (application specific).

Целые числа (Integer)
---------------------

Позитивные числа могут содержать лидирующий знак плюс (`+`).

Отрицательные числа записываются со знаком минус (`-`).

```toml
int1 = +99
int2 = 42
int3 = 0
int4 = -17
```

Большие числа вы можете разбить знаком подчеркивания, для улучшения читаемости.
Каждый знак подчеркивания ДОЛЖЕН быть окружен хотя бы одной цифрой с каждой 
стороны.

```toml
int5 = 1_000
int6 = 5_349_221
int7 = 1_2_3_4_5 # ПРАВИЛЬНО, но не рекомендуется 
```

Лидирующие нули в записи ЗАПРЕЩЕНЫ. Целые значения `-0` и `+0` корректны и 
идентичны нулю без знака (`0`).

Неотрицательные целые значения могут быть выраженны в шестнадцатеричной, 
восьмеричной или двоичной форме. В этой форме, лидирующие нули разрешены 
(после префикса). Шестнадцатеричные значения не чувствительны к регистру.
Знак подчеркивания разрешен между цифрами (но не между префиксом и значением).

```toml
# Шестнадцатеричные числа с префиксом `0x`
hex1 = 0xDEADBEEF
hex2 = 0xdeadbeef
hex3 = 0xdead_beef

# Восьмеричные числа с префиксом `0o`
oct1 = 0o01234567
oct2 = 0o755 # полезно для описания прав доступа к файлы в Unix

# Двоичные числа с префиксом `0b`
bin1 = 0b11010110
```

64 бита (`signed long`) имеют диапазон значений от `−9_223_372_036_854_775_808` 
до `9_223_372_036_854_775_807`. 

*(Прим. видимо, подразумевается, что целые числа
хранятся в токам бинарном представлении, так как являются наиболее популярным 
в контексте текущих архитектур процессоров)*

Числа с плавающей точкой
------------------------

Числам с плавающей точкой следует реализовывать как IEEE 754 binary64 значения.

Число с плавающей точкой состоит из целой части (которая следует тем же правилам,
что и Целые Числа) с следующей за ней дробной частью и/или экспонентой. Если 
и дробная часть и экспонента присутствует, то дробная часть ДОЛЖНА быть перед 
экспонентой.

```toml
# С дробной частью
flt1 = +1.0
flt2 = 3.1415
flt3 = -0.01

# С экспонентой
flt4 = 5e+22
flt5 = 1e6
flt6 = -2E-2

# И с дробной, и с экспонентой
flt7 = 6.626e-34
```

Дробная часть описывается как точка (`.`) с одной и более последующей цифрой.

Часть с экспонентой описывается латинской буквой `E` (в обоих регистрах) с 
последующим Целым Числом.

Аналогично Целым Числам, знак подчеркивания может быть использован для повышения
читаемости числа. Каждый знак подчеркивания ДОЛЖЕН быть окружен как минимум одной
цифрой.

```toml
flt8 = 9_224_617.445_991_228_313
```

Числа с плавающей точкой `-0.0` и `+0.0` корректны и должны обрабатываться в 
соответствии с IEEE 754.

Специальные значения для чисел с плавающей точкой могут быть также выражены.
Они всегда записываются в нижнем регистре.

```toml
# Бесконечности
sf1 = inf  # Положительная бесконечность
sf2 = +inf # Положительная бесконечность
sf3 = -inf # Отрицательная бесконечность

# Не число (NaN, not a number)
sf4 = nan  # реальное sNaN/qNaN кодирование зависит от реализации
sf5 = +nan # тоже что и `nan`
sf6 = -nan # корректно, кодирование зависит от реализации
```

Логический тип (Boolean)
------------------------

Логический тип - это всего лишь ключевые слова (tokens), которые все используют.
Всегда в нижнем регистре.

```toml
bool1 = true
bool2 = false
```

Тип Даты/Времени с часовым поясом (Offset Date-Time)
----------------------------------------------------

Чтобы однозначно описать конкретный момент во времени, вы можете использовать 
[RFC 3339](http://tools.ietf.org/html/rfc3339) формат Даты и Времени с указанием
часового пояса.

```toml
odt1 = 1979-05-27T07:32:00Z
odt2 = 1979-05-27T00:32:00-07:00
odt3 = 1979-05-27T00:32:00.999999-07:00
```

Для читаемости, вы можете заменить разделитель `T` между Датой и Временем на
Пробел (как разрешено RFC 3339 в разделе 5.6).

```toml
odt4 = 1979-05-27 07:32:00Z
```

Точность долей секунды зависит от реализации, но ожидается точность как минимум
до миллисекунд. Если значение содержит большую точность, чем поддерживает 
реализация, то эта дополнительная точность может быть отброшена, без округления.

Местная Дата/Время (Local Date-Time)
------------------------------------

Если вы не укажите часовой пояс, как в [RFC 3339](http://tools.ietf.org/html/rfc3339),
то такое значение будет обозначать дату/время без привязки к временному сдвигу или
часовому поясу. Такое значение не может быть преобразовано к конкретному моменту
времени без какой-либо дополнительной информации. Конвертация в конкретный момент 
времени, если требуется, зависит от реализации.

```toml
ldt1 = 1979-05-27T07:32:00
ldt2 = 1979-05-27T00:32:00.999999
```

Точность долей секунды зависит от реализации, но ожидается точность как минимум
до миллисекунд. Если значение содержит большую точность, чем поддерживает 
реализация, то эта дополнительная точность может быть отброшена, без округления.

Местная дата (Local Date)
-------------------------

Если вы включите только часть, описывающую Дату в 
[RFC 3339](http://tools.ietf.org/html/rfc3339), то данное значение представляет
весь день без привязки к временной корректировке или часовому поясу.

```toml
ld1 = 1979-05-27
```

Местное время (Local Time)
--------------------------

Если вы включите только часть Времени из [RFC 3339](http://tools.ietf.org/html/rfc3339),
то данное значение будет представлять время без привязки к конкретному дню,
временной корректировке или часовому поясу.

```toml
lt1 = 07:32:00
lt2 = 00:32:00.999999
```

Точность долей секунды зависит от реализации, но ожидается точность как минимум
до миллисекунд. Если значение содержит большую точность, чем поддерживает 
реализация, то эта дополнительная точность может быть отброшена, без округления.

Массив (Array)
-----

Массивы описываются квадратными скобками, содержащими внутри набор значений
(элементов). Пробелы игнорируются. Элементы разделяются запятой. Массив не должен
иметь элементов с разными типами (различные способы описать Строки следует
рассматривать как один и тот же тип).

```toml
arr1 = [ 1, 2, 3 ]
arr2 = [ "red", "yellow", "green" ]
arr3 = [ [ 1, 2 ], [3, 4, 5] ]
arr4 = [ "all", 'strings', """are the same""", '''type''']
arr5 = [ [ 1, 2 ], ["a", "b", "c"] ]

arr6 = [ 1, 2.0 ] # НЕВЕРНО
```

Массивы могут также располагаться на нескольких линиях. Завершающая запятая
(также известная как `trailing commas`[болтающаяся запятая]) после последнего
значения в массиве приемлема. Допустимо использовать произвольное число 
Переносов Строк и комментариев перед значением и закрывающейся квадратной
скобкой.

```toml
arr7 = [
  1, 2, 3
]

arr8 = [
  1,
  2, # Этот комментарий и болтающаяся запятая корректны
]
```

Таблица (Table)
---------------

Таблицы (также известные, как hash-таблицы или словари (dictionaries)) описывают
коллекцию пар Ключ/Значение. Они появляются с названием в квадратных скобках на
отдельной линии. Их можно отличить от массивов потому что Массивы - это только 
Значения *(Прим. А также массив присвоен Ключу с определенным названием)*.

```toml
[table]
```

Далее, до тех пор пока не начнется новая Таблица или не встретится конец файла
(EOF) все пары Ключ/Значение принадлежат этой таблице. Порядок перечисления
пар Ключ/Значение никак не гарантируется.

```toml
[table-1]
key1 = "какая-то строка"
key2 = 123

[table-2]
key1 = "другая строка"
key2 = 456
```

Правила обозначения названий для Таблиц те же, что и для Ключей (См. раздел выше).

```toml
[dog."tater.man"]
type.name = "pug"
```

В землях JSON, эта запись была бы эквивалентна следующей структуре:

```json
{ "dog": { "tater.man": { "type": { "name": "pug" } } } }
```

Пробельные символы вокруг Ключа таблицы игнорируются, тем не менее рекомендуется
не использовать ненужные Пробельные символы вообще.

```toml
[a.b.c]            # Это наилучший вариант (best practice)
[ d.e.f ]          # тоже самое, что [d.e.f]
[ g .  h  . i ]    # тоже самое, что [g.h.i]
[ j . "ʞ" . 'l' ]  # тоже самое, что [j."ʞ".'l']
```

Не нужно определять Супер-Таблицу, если вам это не нужно. TOML осведомлен, как 
это обрабатывать.

```toml
# [x] вы
# [x.y] не
# [x.y.z] должны это делать
[x.y.z.w] # для этого объявления
```

Пустые Таблицы разрешены, как Хеш Таблицы не имеющие пар Ключ/Значение.

Подобно Ключам, НЕЛЬЗЯ объявлять Таблицу с одним и тем же именем более одного
раза. Делать так НЕПРАВИЛЬНО.

```
# НЕ ДЕЛАЙТЕ ЭТО

[a]
b = 1

[a]
c = 2
```

```
# И НЕ ДЕЛАЙТЕ ТАКЖЕ ЭТО

[a]
b = 1

[a.b]
c = 2
```

Однострочная Таблица (Inline Table)
-----------------------------------

Однострочная Таблица доставляет более компактный синтаксис для описания
Хэш-Таблиц. Они особенно полезны для группировки данных, которые быстро 
становятся читаемыми (verbose). Однострочные Таблицы обрамлены ~~завитушками~~
фигурными скобками (curly braces) `{` и `}`. Внутри этих скобок может содержаться
ноль и более пар Ключ/Значение разделенных запятой. Пары Ключ/Значение имеют
ту же форму, как и в стандартных Таблицах. Значения всех типов разрешены,
включая Однострочные Таблицы.

Однострочные таблицы намеренно размещаются только в одной линии. Перенос строки 
не разрешен между фигурными скобками, до тех пор пока они не допустимы в пределах 
значений. Даже таким образом, СТРОГО НЕ РЕКОМЕНДУЕТСЯ разбивать Однострочную 
Таблицу на несколько линий. Если вы одержимы этим, то это значит только лишь то,
что стоит использовать обычные Таблицы.

```toml
name = { first = "Tom", last = "Preston-Werner" }
point = { x = 1, y = 2 }
animal = { type.name = "pug" }
```

Однострочные Таблицы выше идентичны следующим стандартным Таблицам:

```toml
[name]
first = "Tom"
last = "Preston-Werner"

[point]
x = 1
y = 2

[animal]
type.name = "pug"

```

Массив Таблиц (Array of Tables)
-------------------------------

Последний тип, который не был ещё описан, - Массив Таблиц. Тип может быть
описан как Название Таблицы внутри двойных квадратных скобок. Каждая таблица
с тем же самым названием будет элементом внутри массива. Таблицы вставляются в
Массив в том же порядке, как и определено в файле. Пустые Таблицы без пар
Ключ/Значение будут рассматриваться как пустые Таблицы.

```toml
[[products]]
name = "Hammer"
sku = 738594937

[[products]]

[[products]]
name = "Nail"
sku = 284758393
color = "gray"
```

В землях JSON, это бы представляло следующую структуру.

```json
{
  "products": [
    { "name": "Hammer", "sku": 738594937 },
    { },
    { "name": "Nail", "sku": 284758393, "color": "gray" }
  ]
}
```

Можно также определять вложенные Массивы Таблиц. Просто используйте синтекс
двойных квадратных скобок на под-таблицах. Каждая под-таблица будет принадлежать
наиболее недавно определенной Таблице выше.

```toml
[[fruit]]
  name = "apple"

  [fruit.physical]
    color = "red"
    shape = "round"

  [[fruit.variety]]
    name = "red delicious"

  [[fruit.variety]]
    name = "granny smith"

[[fruit]]
  name = "banana"

  [[fruit.variety]]
    name = "plantain"
```

The above TOML maps to the following JSON.

```json
{
  "fruit": [
    {
      "name": "apple",
      "physical": {
        "color": "red",
        "shape": "round"
      },
      "variety": [
        { "name": "red delicious" },
        { "name": "granny smith" }
      ]
    },
    {
      "name": "banana",
      "variety": [
        { "name": "plantain" }
      ]
    }
  ]
}
```

Попытка добавить элементы в статически описанный массив, даже если он пуст и 
имеет совместимый тип, ДОЛЖНА вызывать ошибку во время синтаксического разбора 
(at parse time).

```toml
# НЕПРАВИЛЬНЫЙ TOML ДОКУМЕНТ
fruit = []

[[fruit]] # Не разрешается
```

Попытка определить обычный Массив с тем же именем, что уже определен ДОЛЖНА 
вызывать ошибку во время синтаксического разбора (at parse time).

```
# НЕПРАВИЛЬНЫЙ TOML ДОКУМЕНТ
[[fruit]]
  name = "apple"

  [[fruit.variety]]
    name = "red delicious"

  # Это конфликт с предыдущей таблицей
  [fruit.variety]
    name = "granny smith"
```

Также можно использовать Однострочные Таблицы, если это подходит для вашего 
случая:

```toml
points = [ { x = 1, y = 2, z = 3 },
           { x = 7, y = 8, z = 9 },
           { x = 2, y = 4, z = 8 } ]
```

Расширение для TOML файлов
--------------------------

TOML файлы должны использовать расширение `.toml`.

MIME Тип
--------

При передаче TOML файлов через Интернет, подходящий MIME тип - `application/toml`.

Сравнение с Другими Форматами
-----------------------------

В каком-то виде TOML очень похож на JSON: простой, хорошо описан (well-specified),
и легко сопоставляется с распространенными типами данных. JSON  отлично подходит 
для сериализации данных, которые читаются и пишутся компьютерными программами.
Отличия начинаются в том, что TOML делает акцент на простоте для человека (чтобы 
читать и писать). Комментарии хороший пример, подтверждающий это: Они не имеют
особой роли при пересылке данных от одной программы к другой, но они очень 
полезны при написании конфигурационных файлов, которые могут редактироваться 
вручную.

YAML формат также ориентирован к написанию конфигурационных файлов как и TOML.
Но в многих случаях, тем не менее, YAML очень сложное решение. TOML нацелен на
простоту, что не встречается в YAML спецификации: http://www.yaml.org/spec/1.2/spec.html
*(Прим. на самом деле, подобные цели есть, но они чуть более специфичны)*

INI формат также часто используется для конфигурационных файлов. Данный формат
не стандартизирован, тем не менее, обычно не служит для обработки более одного
уровня вложенности.

Принять участие
---------------

Документация, сообщения об ошибках (bug reports), запросы на изменения
(pull requests), и прочее участие приветствуется!

Wiki
----------------------------------------------------------------------

Существует [официальная TOML Wiki](https://github.com/toml-lang/toml/wiki),
которая содержит список:

* Проектов, использующие TOML
* Реализаций (Implementations)
* Валидаторов (Validators)
* Языко-независимые тесты для TOML кодировщиков и декодировщиков
* Поддержка редактора
* Кодировщики (Encoders)
* Конверторы (Converters)

Пожалуйста, посмотрите там, если вы хотели бы видеть или добавить в данные списки.
Спасибо вам, за участие в жизни TOML сообщества!
